import base64
import json
import os
import requests
from datetime import datetime
from pathlib import Path

from app.crypto.aes_utils import encrypt_aes_gcm
from app.crypto.hmac_utils import compute_hmac
from app.crypto.paillier_utils import generate_paillier_keypair, encrypt_paillier
from app.crypto.rsa_utils import (
    generate_rsa_keypair,
    serialize_public_key,
    deserialize_private_key,
    deserialize_public_key,
    wrap_key,
    sign_data,
)

SERVER_URL = "http://127.0.0.1:8000/api/v1/alerts/submit"
HMAC_KEY = os.environ.get("HMAC_BEACON_KEY", "demo-hmac-beacon-key-32").encode()

# Load the org1 keys generated by keygen.py
ORG_ID = "org1"
KEYS_DIR = Path(__file__).resolve().parents[2] / "keys"
PRIVATE_KEY_PATH = KEYS_DIR / f"{ORG_ID}_private.pem"
PUBLIC_KEY_PATH = KEYS_DIR / f"{ORG_ID}_public.pem"

def build_encrypted_alert() -> dict:
    payload = {
        "title": "Suspicious Beacon Activity",
        "description": "Observed repeated DNS lookups to known malicious domains.",
        "severity": "high",
        "classification": "command-and-control",
        "risk_score": 7,
        "detected_at": datetime.utcnow().isoformat(),
        "metadata": {
            "indicators": ["c2.example.bad", "198.51.100.42"],
            "mitre_tags": ["T1071.001", "T1090"],
        },
        "shared_with": ["cert-internal"],
    }

    json_payload = json.dumps(payload).encode()

    # Load the RSA keys from files
    if not PRIVATE_KEY_PATH.exists() or not PUBLIC_KEY_PATH.exists():
        raise FileNotFoundError(
            f"RSA keys not found. Please run 'python src/scripts/keygen.py' first.\n"
            f"Expected files:\n  {PRIVATE_KEY_PATH}\n  {PUBLIC_KEY_PATH}"
        )
    
    with open(PRIVATE_KEY_PATH, "rb") as f:
        rsa_private = deserialize_private_key(f.read())
    with open(PUBLIC_KEY_PATH, "rb") as f:
        rsa_public = deserialize_public_key(f.read())

    # 1. AES encrypt
    aes_key = os.urandom(32)
    aes_ciphertext_b64 = encrypt_aes_gcm(json_payload, aes_key)

    # 2. RSA wrap key
    wrapped_key_bytes = wrap_key(aes_key, rsa_public)
    wrapped_key_b64 = base64.b64encode(wrapped_key_bytes).decode()

    # 3. RSA sign the encrypted payload (not the original plaintext)
    encrypted_payload_bytes = base64.b64decode(aes_ciphertext_b64)
    signature_bytes = sign_data(rsa_private, encrypted_payload_bytes)
    signature_b64 = base64.b64encode(signature_bytes).decode()

    public_key_pem = serialize_public_key(rsa_public).decode()

    # 4. HMAC beacon
    hmac_beacon = compute_hmac(payload["classification"], key=HMAC_KEY)

    # 5. Paillier encrypt risk score
    paillier_public, _ = generate_paillier_keypair()
    risk_cipher = encrypt_paillier(paillier_public, payload["risk_score"])
    paillier_cipher_serialized = json.dumps({
        "ciphertext": str(risk_cipher.ciphertext()),
        "exponent": risk_cipher.exponent,
        "public_key_n": str(paillier_public.n),
    })

    # Match field names expected by alerts.py /submit endpoint
    return {
        "encrypted_payload": aes_ciphertext_b64,       # was "aes_ciphertext"
        "wrapped_aes_key": wrapped_key_b64,            # was "rsa_encrypted_key"
        "signature": signature_b64,
        "hmac_beacon": hmac_beacon,
        "paillier_ciphertext": paillier_cipher_serialized,
        "sender_public_key": public_key_pem,
    }

def submit_alert(alert: dict) -> None:
    resp = requests.post(SERVER_URL, json=alert, timeout=10)
    print(f"Response {resp.status_code}: {resp.text}")

if __name__ == "__main__":
    alert_payload = build_encrypted_alert()
    print("Prepared alert payload:")
    print(json.dumps(alert_payload, indent=2))
    submit_alert(alert_payload)